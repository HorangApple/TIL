# chapter 05. DB 기타 실무 응용

## section 80. 시스템 카탈로그 - D

### 1. 시스템 카탈로그(Sytem Catalog)의 개념

DB에 저장되어 있는 모든 데이터 개체들에 대한 정의나 명세에 대한 정보가 수록 되어 있는 시스템 테이블

- 데이터 사전(Data Dictionary)라고도 한다.
- DDL의 결과로 구성되는 기본 릴레이션, 인덱스, 뷰, 사용자 등의 DB 구조 및 통계 정보가 저장된다.
- 시스템 카탈로그에 저장된 내용을 메타데이터(Metadata)라고 한다.
- 사용자와 DBMS의 접근이 가능하다.

이하 생략



## section 81. 인덱스 - C

### 1. 인덱스(index)의 개념

> 데이터 레코드(튜플)에 빠르게 접근하기 위해 <키 값, 포인터> 쌍으로 구성되는 데이터 구조이다.

- 색인이 없으면 모든 데이터 페이지를 다 뒤지는 TABLE SCAN이 발생한다.
- 기본 인덱스 - 기본키를 위한 인덱스
- 보조 인덱스 - 기본 인덱스가 아닌 인덱스
- 클러스터(Cluster) 인덱스 - 레코드의 물리적 순서 == 인덱스의 엔트리 순서
- 대표적인 인덱스로 m-원 검색 트리, B-트리, B*-트리, B+-트리 등이 있다.

### 2. m-원 검색 트리(m-Way Search Tree)

> 이진 검색 트리를 일반화한 트리로서 한 노드가 최대 m-1개의 키 값과 최대 m개의 서브 노드를 갖는다.

- 이진 검색 트리에 비해 분기율 향상 -> 트리 깊이가 낮아져 검색 시간이 감소
- 트리 균형을 유지하기 위한 복잡한 연산이 수반

### 3. B-트리

> 인덱스를 구성하는 방법으로 많이 사용되는 균형된 m-원 검색 트리이다.

### 4. B*-트리

> B-트리의 문제점인 빈번한 노드의 분항르 줄이는 목적으로 제시된 B-트리의 변형이다.

### 5. B+-트리
> B-트리의 변형으로 단말 노드가 아닌 노드로 구성된 인덱스 세트(Index Set)와 단말 노드로만 구성된 순차 세트(Sequence Set)로 구분된다.



## section 82. 트랜잭션 - C

### 1. 트랜잭션(Transaction)의 정의

> DB에서 하나의 논리적 기능을 수행하기 위한 일련의 연산 집합으로서 작업의 단위이다. 또한 DBMS에서 회복 및 병행 수행 시 처리되는 작업의 논리적 단위이다.

- 정상적으로 종료될 경우 COMMIT 연산이 수행되고, 비정상적으로 종료될 경우 ROLLBACK 연산이 수행된다.

### 2. 트랜잭션의 특성
데이터의 무결성(Integrity)을 보장하기 위해 갖춰야할 특성이다.
**원자성(Atomicity)**
> DB에 모두 반영되든지 아니면 전혀 반영되지 않아야한다.

**일관성(Consistency)**
> 수행이 성공하면 언제나 일관성 있는 DB 상태로 변환한다.

**독립성(Isolation)**
> 트랜잭션이 완료되기 전에는 갱신중인 데이터를 다른 트랜잭션들이 접근하지 못하도록 해야한다.

**영속성(Durablility)**
> 실행 완료된 후에는 시스템에 오류가 발생하더라도 트랜잭션에 의해 변경된 내용은 계속 보존되어야 한다.

### 3. 트랜잭션의 상태
- 활동(Active)
- 실패(Failed)
- 철회(Aborted) : ROLLBACK 연산을 수행한 상태
- 부분 완료(Partially Committed) : COMMIT 연산을 실행하기 전 상태
- 완료(Committed)

## section 83. 회복(Recovery) - D
### 1. 회복(Recovery)의 개념
트랜잭션들을 실행하는 도중 장애(Failure)가 발생하여 DB가 손상되었을 경우 손상되기 이전의 정상 상태로 복구하는 작업이다.

### 2. 장애의 유형

### 3. 회복 관리기(Recovery Manager)

### 4. 회복 기법

이하 생략

## section 84. 병행제어(Concurrency Control) - C
### 1. 병행 제어(Concurrency Control)의 개념
> 동시에 여러 개의 트랜잭션을 병행 수행할 때 DB의 일관성을 파괴하지 않도록 트랜잭션 간의 상호 작용을 제어하는 기술이다.
- 병행성 : 여러 트랜잭션들이 동시에 인터리빙(Interleaving)하게 실행되는 것

### 2. 병행 제어의 목적
- DB 공유 최대화
- 시스템의 활용도 최대화
- 사용자에 대한 응답 시간을 최소화
- 단위 시간당 트랜잭션 처리 건수를 최대화
- DB의 일관성을 유지

### 3. 병행제어의 필요성
> 병행 제어 없이 DB에 동시에 접근하도록 허용할 경우 다음과 같은 문제점이 발생한다.
- 갱신 분실 (Lost Update) : 2개 이상의 트랜잭션이 같은 데이터를 공유하여 갱신할 때 갱신 결과의 일부가 없어지는 현상
- 모순성 (Inconsistency) : 복수의 사용자가 같은 데이터를 동시에 갱신할 때 DB 내의 데이터들이 상호 일치하지 않아 모순된 결과가 발생하는 현상
- 연쇄 복귀 (Cascading Rollback) : 어느 하나에 문제가 생겨 Rollback 되는 경우 다른 트랜잭션들도 함께 Rollback되는 현상

### 4. 잠금(Lock)
> DB 관리에서 하나의 트랜젝션에 사용되는 데이터를 다른 트랜잭션이 접근하지 못하게 하는 것을 의미한다.
- 데이터를 갱신할 때는 잠금(Lock) -> 실행(Execute) -> 해제(Unlock)의 규칙을 따라야 한다.
- 데이터베이스 > 테이블 > 레코드 > 필드 순으로 Locking Overhead는 감소하나 공유성이 낮아짐
- 교착 상태(Dead Lock)

### 5. 병행 제어 기법의 종류
**2-단계 잠금 규약(Two-Phase Lock Protocol) 기법**
> 트랜잭션 스케줄의 직렬성을 보장함
- 확장(Growing) 단계 : 트랜잭션이 잠금만 수행
- 축소(Shrinking) 단계 : 트랜잭션이 잠금 해제만 수행
- 교착 상태를 예방할 수 없음

**타임 스탬프 순서(Time Stamp Ordering) 기법**
> 타임 스탬프는 시스템이 각 트랜잭션을 실행할 때 부여하는 값이며 인터리빙하게 실행한 결과가 타임 스템프 순서대로 트랜잭션들을 실행하는 직렬 스케줄의 실행 결과와 항상 동일하다는 것을 보장하는 기법이다.

## section 85. 보안(Security) - D
### 1. 보안(Security)의 개념

### 2. 보안 기술의 목표

### 3. 보안 기법

이하 생략

## section 86. 튜링(Tuning) - C
### 1. 튜닝(Tuning)의 개요
> DB 응용 프로그램, DB 자체, 운영체제 등의 조정을 통하여 DBMS의 성능을 향상시키는 작업을 말한다.
- DBMS이 높은 작업 처리량과 짧은 응답 시간을 갖도록 하는 것이 중요하다.

### 2. 튜닝의 목표
- SQL문 실행 시 디스크 블록에 대한 접근 횟수를 최소화한다.
- 한번 읽어온 데이터는 메모리 영역에 보관하여 필요시 메모리에서 신속히 가져오게 한다.
- 이름 작성 규칙을 준수하여 작성한다.
- 자원들을 안정적으로 접근할 수 있도록 허용하기 위해 잠금 기능의 사용을 최소화한다.

### 3. 튜닝의 단계
**비즈니스 규칙(Business Rule) 튜닝**
- 시스템의 설계와 구현에 대한 정확하지 않은 분석이나 부적절한 비즈니스 규칙으로 인해 발생된다.
- 동시에 많은 사용자들이 접속하는 현실적인 환경을 고려해야 한다.

**데이터 설계(Data Design) 튜닝**
- 필요한 데이터가 무엇인지 정확히 파악한다.
- 데이터 간의 관계와 속성을 명확히 파악한 후 정보의 구조화 작업을 수행한다.

**응용 프로그램 설계(Application Design) 튜닝**
- 프로세스 부하가 발생하는 시점에서 해당 응용 프로그램 실행에 필요한 시간 및 데이터들을 조사한다.

**DB의 논리적 구조(Logical Structure) 튜닝**
- 작업 부하가 예상되는 질의와 갱신을 고려하여 스키마를 작성함으로써 DBMS의 성능을 향상시키기 위한 효율적인 DB의 논리적 구조를 생성한다.

**DB 접근 방식(Access Method) 튜닝**
- SQL의 장점과 응용 프로그램의 작업 처리를 최대화시키기 위해 DBMS의 기능을 충분히 활용한다.

**접근 경로(Access Path) 튜닝**
- B-트리 인덱스, 비트맵 인덱스 등 사용을 고려한다.
- 원하는 응답 속도를 얻기 위해 인덱스의 추가 및 삭제는 물론 설계의 개선도 고려되어야 한다.

**메모리 관리(Memory Management) 튜닝**
- 메모리 자원을 효율적으로 할당하여 캐시의 성능을 개선하고 SQL문의 파신 작업을 감소시킨다.

**물리적 구조(Physical Structure) 및 입출력(Input/Output) 튜닝**
- 효율적인 데이터 블록 운영을 고려하여 적용한다.
- 디스크 간에 데이터를 분산하여 입출력 경합을 감소시킨다.

**자원의 경합(Competition) 튜닝**
- 블록, 공유 풀(shared Pool), 잠금(Lock) 등의 경합 형태를 감소시키기 위한 노력을 계속 수행하여야한다.

**H/W 시스템에 특화된 부분의 튜닝**
- H/W 시스템의 종류와 특서에 따라 성능의 차이가 나타난다.

### 4. 인덱스 튜닝
**인덱스 종류**
- B-트리 인덱스 : 루트 노드에서 하위 노트로 키 값의 크기를 비교하며 검색
- 비트맵 인덱스 : 인덱스 컬럼의 데이터를 0 또는 1로 변환하여 인덱스 키로 사용
- 역방향 인덱스 : 인덱스 컬럼의 데이터를 역으로 변환하여 인덱스 키로 사용
- 클러스터드 인덱스 : 인덱스 키의 순서에 따라 데이터 정렬
- 넌클러스터드 인덱스 : 인덱스 키 값만 정렬되어 있고 실제 데이터는 정렬되지 않음

**인덱스 선정 기준**
- 분포도가 좋은 컬럼은 단독으로 인덱스를 생성한다.
- 데이터의 변경이 빈번하지 않은 컬럼에 인덱스를 생성한다.
- 인덱스들이 자주 조합되어 사용되는 경우는 하나의 결합 인덱스(Concatenate Index)를 생성한다.
- 데이터의 분포도가 낮은 컬럼을 선행 컬럼으로 설정한다.

**인덱스를 사용하지 못하는 경우**
- 인덱스 키 생성 시 NULL 값은 인덱스 대상에 포함되지 않다.
- 부정 연산자는 전체 테이블을 대상으로 검색할 때 사용한다.
- 첫 글자를 바로 알 수 없기 때문에 정렬되어 있는 인덱스를 처음부터 검색해야한다.
- 인덱스 컬럼에 함수나 수식을 사용하면 인덱스 키 값이 변형된다.

## section 87. 객체 지향 데이터베이스 - D
### 1. 객체 지향 데이터베이스(ODB; Object-oriented Database)

### 2. 객체 지향 데이터베이스의 구성

### 3. 객체 관계 데이터베이스(ORDB; Object Relational Database)

## section 88. 고급 데이터베이스 - B
### 1. 분산 데이터베이스(Distributed Database)
> 논리적으로는 같은 시스템, 물리적으로는 컴퓨너 네트워크를 통해 분산되어 있는 데이터베이스이다.

**분산 데이터베이스 시스템의 구성요소**
- 분산 처리기 : 지리적으로 분산되어 있는 컴퓨터 시스템
- 분산 데이터베이스 : 지리적으로 분산되어 있는 데이터베이스
- 통신 네트워크 : 분산 처리기들을 통신망으로 연결하여 논리적으로 하나의 시스템처럼 작동할 수 있도록 하는 네트워크

**분산 데이터베이스의 목표**
- 위치 투명성 : DB의 논리적인 명칭으로만 접근할 수 있음
- 중복 투명성 : 마치 하나의 데이터만 존재하는 것처럼 사용할 수 있음
- 병행 투명성 : 트랜잭션들의 수행 결과는 서로 영향을 받지 않음
- 장애 투명성 : 장애에도 불구하고 트랜잭션은 정확하게 수행됨

### 2. 멀티미디에 데이터베이스(Multimedia Database)
> 텍스트, 그래픽, 정지 화상, 동영상, 음성 등이 복합적으로 구성된 데이터베이스이다.

**멀티미디어 데이터베이스의 특성**
- 데이터가 대용량
- 미디어별로 별도의 검색 방법이 필요
- 비정형 데이터이기 때문에 구조가 복잡하고 관계를 구성하기가 어려움

**멀티미디어 데이터베이스 구축 방법**
- 파일 기반 기법
- 관계형 데이터베이스 기반 기법
- 객체 지향 데이터베이스 기반 기법
- 객체 관계형 데이터베이스 기반 기법

### 3. 주기억장치 데이터베이스(Main Memory Database)
> DB 전체를 주기억장치에 상주시킨 후 연산을 수행하는 시스템으로, 디스크 입출력이 발생하지 않는다.

**주기억장치 데이터베이스의 특성**
- 디스크 입출력이 없어 빠른 연산이 가능
- 회복 작업의 구현이 어려움
- 주기억장치가 비쌈

### 4. 데이터 웨어하우스(Data Warehouse)
> 급증하는 다량의 데이터를 효과적으로 분석하여 정보화하고 이를 여러 계층의 사용자들이 효율적으로 사용할 수 있도록 한 데이터베이스이다.

- 등장 동기는 전사적인 데이터 통합을 통한 정보의 효율적인 분석이 필요하게 되었고, 신속 정확한 의사결정을 위해 의사결정용 데이터베이스의 필요성이 대두되었다.

### 5. 데이터 마트(Data Mart)
> 데이터 웨어하우스로부터 특정 주제나 부서 중심으로 구축된 소규모 단일 주제의 데이터 웨어하우스를 말한다.

- 전사적 통합성을 염두에 두고 데이터 웨어하우스보다 먼저 구축될 수 있다.

**데이터 마트의 특징**
- 데이터를 분석 요건에 적합한 구조로 재구성함
- 요약 데이터로 구성되며, 필요시 일부 상세 데이터 포함
- 분석에 필요한 이력 데이터만을 포함하는 제한된 규모의 데이터
- 유연성과 접근성이 뛰어난 다차원 구조의 데이터

### 6. 데이터 마이닝(Data Mining)
> 데이터 집합에서 사용자의 요구에 따라 유용하고 가능성 있는 정보를 발견하기 위한 기법이다.

**데이터 마이닝의 기법**
- 연관(Association)
- 연속(Sequence)
- 분류(Classification)
- 클러스터링(Clustering, 군집화)
- 특성화(Characterization)
- 패턴 분석(Pattern Analysis)
- 경향 분석(Trend Analysis)

### 7. OLAP(Online Analytical Processing)
> 다차원 데이터로부터 통계적인 요약 정보를 분석하여 의사결정에 활용하는 방식
- 데이터 웨어하우스나 데이터 마트와 같은 시스템과 상호 연관되는 정보 시스템
- 데이터 웨어하우스의 데이터를 전략적인 정보로 변환시키는 역할을 함
- 중간 매개체 없이 이용자들이 직접 컴퓨터를 이용하여 데이터에 접근하는 데 있어 필수적인 시스템이라 할 수 있음

**OLAP 연산**
- Roll-up : 상세 데이터부터 요약된 형태의 데이터로 접근
- Drill-down : 요약된 형태의 데이터부터 상세 데이터로 접근
- Drill-through : 데이터 웨어하우스나 OLTP에 존재하는 상세 데이터에 접근
- Drill-across : 다른 데이터 큐브의 데이터에 접근
- Pivoting : 행, 열, 페이지 차원을 바꾸어 볼 수 있는 기능
- Slicing : 다양한 각도에서 조회하고 자유롭게 비교하는 기능
- Dicing : Slicing을 더 세분화하는 기능

**OLAP 종류**
- ROLAP(Relational) : RDB와 관계형 질의어 사용함
- MOLAP(Multi-dimension) : 큐브 캐시(Cube Cache)라는 주기억장치 속에 데이터 큐브를 보관함
- HOLAP(hybird) : ROLAP + MOLAP, 요약을 메모리에 저장하고 기본 데이터나 다른 요약들은 RDB에 저장함

### 8. OLTP(Online Transaction Processing)
> 네트워크상의 여러 이용자가 실시간으로 DB 데이터를 갱신하거나 검색하는 등의 단위 작업을 처리하는 방식을 말한다.

- 트랜잭션이 단위 작업이며 작업 수행이 성공 또는 실패 중 하나로 처리되어야한다.
- 빠른 응답 시간을 요구하며, 개개의 레코드를 효율적으로 조회 및 수정할 수 있도록 정규화 되어 있다.

### 9. ODBC(Open Database Connectivity)
> 프로그램, 데이터베이스의 종류에 관계없이 자유롭게 데이터베이스에 접근하여 사용할 수 있도록 MS에서 만든 API이다.

- ODBC 드라이버를 통해 DB에 따른 차이에 상관 없이 ODBC 기준에 맞게 응용 프로그램을 작성하기만 하면 된다.
- DB를 교체하더라도 기존의 응용 프로그램을 그대로 사용할 수 있다.

**ODBC의 구조**
- Application
- Driver Manager
- DSN(Domain Service Name)
- ODBC Driver
- 데이터베이스