# Vue.js

## 1. life cycle

life cycle은 일반적으로 app 가지고 있는 생성부터 제거까지의 생명주기를 말한다. 다음으로 설명할 method들은 인스턴스가 생성되었을 때 호출할 동작을 정의하는 속성들을 말한다. 그리고 각 life cycle 속성에서 실행되는 커스텀 로직을 life cycle hook 이라고 한다.

### 1.1 인스턴스를 DOM에 부착할 때까지

- beforeCreate: data, methods가 아직 인스턴스에 정의되지 않음, DOM도 접근불가
- created: component와 data, methods가 정의됨, HTTP 통신 가능
- beforeMount: DOM에 인스턴스가 부착되기 직전, 로직을 추가하기 좋음.
- mounted: DOM에 인스턴스가 부착된 후의 시점, DOM에 접근 가능

### 1.2 인스턴스의 데이터가 갱신 될 때까지

- beforeUpdate: 관찰하고 있는 데이터가 변경되면 가상 DOM에 화면을 다시 그리기 전에 호출되는 단계, 변경 예정인 새 데이터에 접근할 수 있으나 그 데이터를 변경하는 로직을 넣더라도 화면이 다시 그려지지 않음.
- updated: 데이터가 변경되고 나서 가상 돔으로 다시 화면을 그리고 나면 실행되는 단계, 변경이 완료된 시점이므로 DOM 제어와 관련한 로직을 추가하기 좋음. 만약 데이터 값을 변경하면 무한 루프에 빠질 수 있으므로 computed나 watch를 사용해야함. 데이터 값을 갱신하는 로직은 beforeUpdate을, DOM와 관련 로직은 updated에 추가하는 것이 좋음.

### 1.3 인스턴스가 소멸 될 때까지

- beforeDestroy: 뷰 인스턴스가 파괴되기 직전, 아직 인스턴스에 접근할 수 있으므로 뷰 인스턴스의 데이터를 삭제하기 좋음.
- destroyed: 뷰 인스턴스가 파괴되고 나서 호출되는 단계, 하위를 포함한 뷰 인스턴스에 정의한 모든 속성이 제거됨.

**예제**
```html
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <div id="app">
      {{message}}
    </div>
    <!-- Vue -->
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <script>
      const app = new Vue({
        el: "#app",
        data: {
          message: "hello"
        },
        beforeCreate: function() {
          console.log("beforeCreate");
        },
        created: function() {
          console.log("created");
        },
        mounted: function() {
          console.log("mounted");
          this.message = "HoU!";
        },
        updated: function() {
          console.log("updated");
        }
      });
    </script>
  </body>
</html>
```

## 2. 컴포넌트(component)

컴포넌트는 화면을 구성할 수 있는 블록 또는 특정 영역을 의미한다. 컴포넌트 간의 관계는 자료구조의 Tree 모양과 유사하다.

컴포넌트의 등록 방법은 전역(Global)과 지역(Local) 방식으로 선언할 수 있는데 전역 컴포넌트는 여러 인스턴스에서 공통으로 사용할 수 있고 지역 컴포넌트는 특정 인스턴스에서 사용할 수 있다.

**예제**
```html
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <div id="app">
      <h1>첫 번째 인스턴스 영역</h1>
      <global-component></global-component>
      <local-component></local-component>
    </div>
    <div id="app2">
      <h1>두 번째 인스턴스 영역</h1>
      <global-component></global-component>
      <local-component></local-component>
      <!-- 오류 발생 -->
    </div>
    <!-- Vue -->
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <script>
      // 전역 컴포넌트
      Vue.component("global-component", {
        template: "<div>Global Component</div>"
      });

      // 지역 컴포넌트 내용
      let cmp = {
        template: "<div>Local Component</div>"
      };

      // 첫 번째 인스턴스
      const app = new Vue({
        el: "#app",
        // 지역 컴포넌트
        components: {
          "local-component": cmp
        }
      });

      // 두 번째 인스턴스
      const app2 = new Vue({
        el: "#app2"
      });
    </script>
  </body>
</html>
```

## 3. 뷰 컴포넌트 통신

뷰는 컴포넌트로 화면을 구성하므로 같은 웹 페이지라도 데이터를 공유할 수 없다. 왜냐하면 컴포넌트마다 고유한 유효 범위(Scope)를 갖기 때문이다.

**예제**
```html
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <div id="app">
      <h1>첫 번째 인스턴스 영역</h1>
      <global-component></global-component>
      <local-component></local-component>
    </div>
    <div id="app2">
      <h1>두 번째 인스턴스 영역</h1>
      <global-component></global-component>
      <local-component></local-component>
      <!-- 오류 발생 -->
    </div>
    <!-- Vue -->
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <script>
      // 전역 컴포넌트
      Vue.component("global-component", {
        // cmp1Data만 출력된다.
        template: "<div>Global Component {{cmp1Data, cmp2Data}}</div>",
        data: function() {
          return {
            cmp1Data: 100
          };
        }
      });

      // 지역 컴포넌트 내용
      let cmp = {
        // cmp2Data만 출력된다.
        template: "<div>Local Component {{cmp2Data, cmp1Data}}</div>",
        data: function() {
          return {
            cmp2Data: 50
          };
        }
      };

      // 첫 번째 인스턴스
      const app = new Vue({
        el: "#app",
        // 지역 컴포넌트
        components: {
          "local-component": cmp
        }
      });

      // 두 번째 인스턴스
      const app2 = new Vue({
        el: "#app2"
      });
    </script>
  </body>
</html>
```

그러나 상-하위 컴포넌트 관계(부모-자식 관계)이면 서로 통신이 가능하다. 부모가 자식에게 통신할 경우에는 `props`를 전달하고 자식이 부모에게 전달할 때는 이벤트 발생을 통해 통신할 수 있다.

### 3.1 부모->자식

```javascript
Vue.component("child-component", {
  props: ["props 속성 이름"]
});
```

`props`를 통해 값을 전달하기 때문에 자식 컴포넌트에 props를 선언해놔야한다.

```html
<child-component
  v-bind:props
  속성
  이름="부모 컴포넌트의 data 속성"
></child-component>
```

html에서 컴포넌트를 사용할 때는 `v-bind`를 이용해 부모 컴포넌트로 부터 data를 받으면 된다.

**예제**
```html
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <div id="app">
      <child-component v-bind:pdata="message"></child-component>
    </div>
    <!-- Vue -->
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <script>
      // 전역 컴포넌트
      Vue.component("child-component", {
        template: "<div>child Component: {{pdata}}</div>",
        props: ["pdata"]
      });

      // 인스턴스도 컴포넌트이다.
      const app = new Vue({
        el: "#app",
        data: {
          message: "data from Parent Component"
        }
      });
    </script>
  </body>
</html>
```

### 3.2 자식->부모

자식 컴포넌트에서 특정 이벤트가 발생하면 상위 컴포넌트에서 해당 이벤트를 수신하여 부모 컴포넌트의 메서드를 호출한다.

이벤트 발생과 수신은 `$emit('이벤트명')`과 `v-on:속성`을 사용하여 구현한다.

```javascript
// 이벤트 발생
this.$emit("이벤트");
```

```html
<!-- 이벤트 수신 -->
<child-component v-on:이벤트명="상위 컴포넌트의 메서드명"></child-component>
```

**예제**
```html
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <div id="app">
      <child-component v-on:show-log="printText"></child-component>
    </div>
    <!-- Vue -->
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <script>
      // 전역 컴포넌트
      Vue.component("child-component", {
        template: "<button v-on:click='showLog'>show</button>",
        methods: {
          showLog: function() {
            this.$emit("show-log");
          }
        }
      });
      s;

      // 인스턴스도 컴포넌트이다.
      const app = new Vue({
        el: "#app",
        data: {
          message: "data from Parent Component"
        },
        methods: {
          printText: function() {
            console.log("이벤트 수신");
          }
        }
      });
    </script>
  </body>
</html>
```

### 3.3 이벤트 버스

같은 레벨, 또는 다른 레벨의 컴포넌트 간의 통신을 하기 위해서는 이벤트 버스(Event Bus)를 사용해야한다. 이벤트 버스를 사용하면 부모 컴포넌트를 거쳐갈 필요 없이 바로 보낼 수 있다.

```javascript
// 이벤트 버스를 위한 추가 인스턴스 1개 생성
let eventBus = new Vue();

//...
// 이벤트를 보내는 컴포넌트
methods:{
  메서드명: function(){
    eventBus.$emit('이벤트명',데이터);
  }
}

//...
// 이벤트를 받는 컴포넌트
methods:{
  created: function(){
    eventBus.$on('이벤트명',function(데이터){
      //...
    });
  }
}
```

**예제**
```html
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <div id="app">
      <child-component></child-component>
    </div>
    <!-- Vue -->
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <script>
      // 이벤트 버스 생성
      let eventBus = new Vue();

      Vue.component("child-component", {
        template: "<button v-on:click='showLog'>show</button>",
        methods: {
          showLog: function() {
            // 이벤트 버스 송신
            eventBus.$emit("triggerEventBus", 100);
          }
        }
      });

      const app = new Vue({
        el: "#app",
        created: function() {
          // 이벤트 버스 수신
          eventBus.$on("triggerEventBus", function(value) {
            console.log("이벤트를 전달받음. 전달받은 값 : ", value);
          });
        }
      });
    </script>
  </body>
</html>
```

이벤트 버스를 활용하면 props 속성을 이용하지 않아도 되지만 컴포넌트가 많아지면 어디로 보냈는지 관리가 되지 않기에 뷰엑스(Vuex)와 같은 상태 관리 도구가 필요하다.

## 4. 라우터
라우팅(Routing)은 웹페이지 간의 이동 방법을 말하며 SPA에서 주로 사용하고 있다. 라우팅을 이용하면 화면 간의 전환 시에 화면 상의 깜빡거리는 현상이 없는 부드러운 전환을 구현할 수 있다. 이런 라우팅을 구현하기 위해서는 라우터를 만들어야 한다. 

### 4.1 뷰 라우터
뷰 라우터는 뷰에서 라우팅 기능을 구현할 수 있도록 지원하는 공식 라이브러리이다. 뷰 라우터는 아래의 CDN 주소를 입력해야 사용할 수 있다.

```html
<!-- Vue-Router -->
<script src="https://unpkg.com/vue-router@2.0.0/dist/vue-router.js"></script>
```

뷰 라우터의 사용법은 다음과 같다.

```html
<!-- 페이지 이동 태그 -->
<router-link to="URL 값"></router-link>

<!-- 페이지 표시 태그,  -->
<router-view></router-view>
```

```javascript
//...
// URL 값에 따라 표시될 컴포넌트 지정
let routes = [
  { path: 'URL 값', component: 컴포넌트 변수명},
  //...
]

// routes를 VueRouter에 연결
let router = new VueRouter({
  routes
})

// Vue 인스턴스에 router 삽입
const app = new Vue({
  router
}).$mount('#app')
```

`$mount()` API는 el 속성과 동일하게 인스턴스 화면에 붙이는 역할을 한다.

**예제**
```html
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <div id="app">
      <p>
        <!-- 링크 정의 -->
        <router-link to="/Message1">Message1</router-link>
        <router-link to="/Message2">Message2</router-link>
      </p>
      <!-- 라우팅 영역 정의 -->
      <router-view></router-view>
    </div>
    <!-- Vue -->
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <!-- Vue-Router -->
    <script src="https://unpkg.com/vue-router@2.0.0/dist/vue-router.js"></script>
    <script>

      const Message1 = Vue.component("Message1-component", {
        template: "<button v-on:click='showLog'>Message1</button>",
        methods: {
          showLog: function() {
            console.log("Message1")
          }
        }
      });

      const Message2 = Vue.component("Message2-component", {
        template: "<button v-on:click='showLog'>Message2</button>",
        methods: {
          showLog: function() {
            console.log("Message2")
          }
        }
      });

      let routes = [
        // 뷰 라우팅
        { path: "/Message1", component: Message1 },
        { path: "/Message2", component: Message2 }
      ];

      let router = new VueRouter({
        mode: 'history', // 라우터 URL의 해시 값(#)을 없앤다.
        routes
      });

      const app = new Vue({
        router
      }).$mount("#app");
    </script>
  </body>
</html>
```
`mode: 'history'`는 해시 값을 없애줄 때 사용하지만 서버가 있어야 제 기능을 활용할 수 있다. 자세한 내용은 [공식 문서](https://router.vuejs.org/kr/guide/essentials/history-mode.html#%EC%84%9C%EB%B2%84-%EC%84%A4%EC%A0%95-%EC%98%88%EC%A0%9C)를 통해 확인하길 바란다.

### 4.2 네스티드 라우터
네스티드 라우터(Nested Router)는 라우터로 페이지를 이동할 때 최소 2개 이상의 컴포넌트를 화면에 나타낼 수 있다. 부모 컴포넌트 1개에 자식 컴포넌트 1개를 포함하는 구조로 구성되지만 URL에 따라 서로 다른 부모 컴포넌트의 자식 컴포넌트가 표시된다.

**예제**
```html
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <div id="app">
      <!-- 라우팅 영역 정의 -->
      <router-view></router-view>
    </div>
    <!-- Vue -->
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <!-- Vue-Router -->
    <script src="https://unpkg.com/vue-router@2.0.0/dist/vue-router.js"></script>
    <script>
      const User = {
        template: `
        <div>
          User Component
          <router-view></router-view>
        </div>
        `
      };
      const Message1 = Vue.component("Message1-component", {
        template: "<button v-on:click='showLog'>Message1</button>",
        methods: {
          showLog: function() {
            console.log("Message1");
          }
        }
      });

      const Message2 = Vue.component("Message2-component", {
        template: "<button v-on:click='showLog'>Message2</button>",
        methods: {
          showLog: function() {
            console.log("Message2");
          }
        }
      });

      let routes = [
        {
          path: "/user",
          component: User,
          // 네스티드 라우팅 정의
          children: [
            // '/'는 떼고 path를 작성해야한다.
            // /user/message1
            { path: "message1", component: Message1 },
            // /user/message2
            { path: "message2", component: Message2 }
          ]
        }
      ];

      let router = new VueRouter({
        routes
      });

      const app = new Vue({
        router
      }).$mount("#app");
    </script>
  </body>
</html>
```

네스티드 라우터는 화면을 구성하는 컴포넌트의 수가 적을 떄는 유용하지만 한 번에 더 많은 컴포넌트를 표시하는데는 한계가 있다.

### 4.3 네임드 뷰
네임드 뷰(Named View)는 특정 페이지로 이동했을 때 같은 레벨의 여러 컴포넌트들을 동시에 표시하는 라우팅 방식이다.

**예제**
```html
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <div id="app">
      <!-- 라우팅 영역 정의 -->
      <router-view name="header"></router-view>
      <router-view></router-view> <!-- name이 없으면 default로 인식 -->
      <router-view name="footer"></router-view>
    </div>
    <!-- Vue -->
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <!-- Vue-Router -->
    <script src="https://unpkg.com/vue-router@2.0.0/dist/vue-router.js"></script>
    <script>
      const User = {
        template: `
        <div>
          User Component
          <router-view></router-view>
        </div>
        `
      };
      const Message1 = Vue.component("Message1-component", {
        template: "<button v-on:click='showLog'>Message1</button>",
        methods: {
          showLog: function() {
            console.log("Message1");
          }
        }
      });

      const Message2 = Vue.component("Message2-component", {
        template: "<button v-on:click='showLog'>Message2</button>",
        methods: {
          showLog: function() {
            console.log("Message2");
          }
        }
      });

      let router = new VueRouter({
        routes: [
          {
            path: "/",
            // 네임드 뷰
            components: {
              default: User,
              header: Message1,
              footer: Message2
            }
          }
        ]
      });

      const app = new Vue({
        router
      }).$mount("#app");
    </script>
  </body>
</html>
```

## 5. 뷰 HTTP 통신